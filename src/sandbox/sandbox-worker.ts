/**
 * Sandbox Worker - Isolated Code Execution with RPC Tool Proxies
 *
 * Story 7.1b / ADR-032: Worker script that executes user code in isolation.
 * Story 7.3b: Capability injection with BroadcastChannel tracing (ADR-036).
 *
 * Security Model:
 * - Runs with `permissions: "none"` (Deno Worker permission)
 * - No direct access to filesystem, network, or environment
 * - Tool calls route through RPC bridge to main process
 * - Capability traces emitted via BroadcastChannel (real-time)
 *
 * @module sandbox/sandbox-worker
 */

/// <reference lib="deno.worker" />

import type {
  BridgeToWorkerMessage,
  CapabilityTraceEvent,
  InitMessage,
  RPCResultMessage,
  ToolDefinition,
} from "./types.ts";

// Declare Worker global scope for TypeScript
declare const self: DedicatedWorkerGlobalScope;

// =============================================================================
// Story 7.3b: Capability Tracing via BroadcastChannel (ADR-036)
// ADR-041: Hierarchical trace tracking with parent_trace_id propagation
// =============================================================================

/**
 * BroadcastChannel for real-time trace emission
 * Bridge subscribes to this channel to receive capability traces
 */
const traceChannel = new BroadcastChannel("cai-traces");

// ADR-041: Context stack for hierarchical trace tracking
// Tracks current trace context (trace_id of active capability)
// Stack supports nested capabilities: [outermost, ..., current]
interface TraceContext {
  trace_id: string;
  capability: string;
  capability_id: string;
}
const __traceContextStack: TraceContext[] = [];

/**
 * Get current trace context (for parent_trace_id propagation)
 * Returns the trace_id of the currently executing capability, or undefined
 */
function __getCurrentTraceId(): string | undefined {
  if (__traceContextStack.length === 0) return undefined;
  return __traceContextStack[__traceContextStack.length - 1].trace_id;
}

// Note: __capabilityDepth is now closure-scoped in the capability context
// (generated by CapabilityCodeGenerator.buildCapabilitiesObject)
// This prevents user code from manipulating it directly (Issue #4 fix)

/**
 * Trace function for capability events
 * Emits traces via BroadcastChannel for real-time collection
 * ADR-041: Manages trace context stack and propagates parent_trace_id
 *
 * @param event - Partial trace event (type, capability, capability_id required)
 */
function __trace(event: Partial<CapabilityTraceEvent>): void {
  try {
    // ADR-041: Generate trace_id for this event
    const trace_id = crypto.randomUUID();

    // ADR-041: Get parent_trace_id from current context (before push/pop)
    const parent_trace_id = event.type === "capability_start"
      ? __getCurrentTraceId() // Parent is the CURRENT top of stack
      : undefined; // For capability_end, parent is already set

    const fullEvent: CapabilityTraceEvent = {
      type: event.type as "capability_start" | "capability_end",
      capability: event.capability || "unknown",
      capability_id: event.capability_id || "unknown",
      trace_id: trace_id,
      ts: Date.now(),
      success: event.success,
      error: event.error,
      parent_trace_id: parent_trace_id,
      args: event.args,
    };

    // ADR-041: Manage trace context stack
    if (event.type === "capability_start") {
      // Push new context onto stack
      __traceContextStack.push({
        trace_id: trace_id,
        capability: event.capability || "unknown",
        capability_id: event.capability_id || "unknown",
      });
    } else if (event.type === "capability_end") {
      // Pop context from stack (find matching capability)
      // Use capability_id to match in case of concurrent calls
      const idx = __traceContextStack.findLastIndex(
        (ctx) => ctx.capability_id === event.capability_id,
      );
      if (idx !== -1) {
        // Update fullEvent.trace_id to match the start event
        fullEvent.trace_id = __traceContextStack[idx].trace_id;
        __traceContextStack.splice(idx, 1);
      }
    }

    traceChannel.postMessage(fullEvent);
  } catch {
    // Never throw - tracing must not break execution
  }
}

// Cleanup on worker termination
self.addEventListener("unload", () => {
  traceChannel.close();
});

/**
 * Pending RPC calls waiting for response from bridge
 */
const pendingCalls = new Map<string, {
  resolve: (value: unknown) => void;
  reject: (error: Error) => void;
}>();

/**
 * RPC call function - sends message to bridge and waits for response
 * ADR-041: Includes parent_trace_id for hierarchical tracking (capability â†’ tool)
 *
 * @param server MCP server identifier
 * @param tool Tool name
 * @param args Tool arguments
 * @returns Tool execution result
 */
async function __rpcCall(
  server: string,
  tool: string,
  args: Record<string, unknown>,
): Promise<unknown> {
  const id = crypto.randomUUID();

  // ADR-041: Get current trace context for parent_trace_id
  const parent_trace_id = __getCurrentTraceId();

  return new Promise((resolve, reject) => {
    pendingCalls.set(id, { resolve, reject });

    // Send RPC request to bridge with parent_trace_id (ADR-041)
    self.postMessage({
      type: "rpc_call",
      id,
      server,
      tool,
      args,
      parent_trace_id, // ADR-041: Propagate trace context
    });
  });
}

/**
 * Generate tool proxy object from definitions
 *
 * Creates an object structure like:
 * ```
 * {
 *   filesystem: {
 *     read_file: (args) => __rpcCall("filesystem", "read_file", args),
 *     write_file: (args) => __rpcCall("filesystem", "write_file", args),
 *   },
 *   memory: {
 *     store: (args) => __rpcCall("memory", "store", args),
 *   }
 * }
 * ```
 */
function generateToolProxies(
  toolDefinitions: ToolDefinition[],
): Record<string, Record<string, (args: Record<string, unknown>) => Promise<unknown>>> {
  const mcp: Record<string, Record<string, (args: Record<string, unknown>) => Promise<unknown>>> =
    {};

  for (const def of toolDefinitions) {
    if (!mcp[def.server]) {
      mcp[def.server] = {};
    }
    mcp[def.server][def.name] = (args: Record<string, unknown>) =>
      __rpcCall(def.server, def.name, args);
  }

  return mcp;
}

/**
 * Execute user code with tool proxies and capabilities available
 *
 * @param code User code to execute
 * @param mcp Tool proxy object
 * @param context Optional context variables
 * @param capabilityContext Optional capability code (inline functions)
 * @returns Execution result
 */
async function executeCode(
  code: string,
  mcp: Record<string, Record<string, (args: Record<string, unknown>) => Promise<unknown>>>,
  context?: Record<string, unknown>,
  capabilityContext?: string,
): Promise<unknown> {
  // Build context variables for injection
  const contextVars = context
    ? Object.entries(context)
      .map(([key, value]) => `const ${key} = ${JSON.stringify(value)};`)
      .join("\n")
    : "";

  // ADR-016: REPL-style auto-return with heuristic detection
  // Check if code contains statement keywords
  const hasStatements =
    /(^|\n|\s)(const|let|var|function|class|if|for|while|do|switch|try|return|throw|break|continue)\s/
      .test(code.trim());

  // If code has statements, execute as-is (requires explicit return)
  // If code is pure expression, wrap in return for auto-return
  const wrappedUserCode = hasStatements ? code : `return (${code});`;

  // Create async function with mcp, capabilities, and tracing injected
  // Using Function constructor (required for dynamic code execution in Worker)
  const AsyncFunction = Object.getPrototypeOf(async function () {}).constructor;

  // Build function body with capability context, context vars, and user code
  // Story 7.3b: __trace is passed as parameter, __capabilityDepth is closure-scoped in capability context
  const functionBody = `
    ${capabilityContext || "let __capabilityDepth = 0;\nconst capabilities = {};"}
    ${contextVars}
    ${wrappedUserCode}
  `;

  // Create and execute the function with mcp and __trace as parameters
  // __capabilityDepth is closure-scoped within capabilityContext (not a parameter)
  const fn = new AsyncFunction("mcp", "__trace", functionBody);

  return await fn(mcp, __trace);
}

/**
 * Handle messages from bridge
 */
self.onmessage = async (e: MessageEvent<BridgeToWorkerMessage>) => {
  const msg = e.data;

  if (msg.type === "init") {
    await handleInit(msg);
  } else if (msg.type === "rpc_result") {
    handleRPCResult(msg);
  }
};

/**
 * Handle init message - setup and execute user code
 * Story 7.3b: Now accepts capabilityContext for inline capability functions
 */
async function handleInit(msg: InitMessage): Promise<void> {
  const { code, toolDefinitions, context, capabilityContext } = msg;

  try {
    // Generate tool proxies from definitions
    const mcp = generateToolProxies(toolDefinitions);

    // Execute user code with capabilities (Story 7.3b)
    const result = await executeCode(code, mcp, context, capabilityContext);

    // Send success response
    self.postMessage({
      type: "execution_complete",
      success: true,
      result,
    });
  } catch (error) {
    // Send error response
    self.postMessage({
      type: "execution_complete",
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
}

/**
 * Handle RPC result message - resolve pending call
 */
function handleRPCResult(msg: RPCResultMessage): void {
  const pending = pendingCalls.get(msg.id);

  if (pending) {
    pendingCalls.delete(msg.id);

    if (msg.success) {
      pending.resolve(msg.result);
    } else {
      pending.reject(new Error(msg.error || "RPC call failed"));
    }
  }
}
